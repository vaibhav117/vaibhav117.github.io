<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>How Torrents Work | Vaibhav Mathur</title> <meta name="author" content="Vaibhav Mathur"> <meta name="description" content="A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. "> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700%7CRoboto+Slab:100,300,400,500,700%7CMaterial+Icons"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css"> <link rel="canonical" href="https://vaibhav117.github.io/blog/2018/How_Torrents_work/"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js"></script> <script src="/assets/js/dark_mode.js"></script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"><span class="font-weight-bold">Vaibhav </span>Mathur</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about</a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog<span class="sr-only">(current)</span></a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">Publications</a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv</a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5"> <div class="post"> <header class="post-header"> <h1 class="post-title">How Torrents Work</h1> <p class="post-meta">August 20, 2018</p> <p class="post-tags"> <a href="/blog/2018"> <i class="fas fa-calendar fa-sm"></i> 2018 </a> </p> </header> <article class="post-content"> <p>Most of us must have used Torrents at some point of our lives. It’s an amazing utility that allows one to download large files with relative ease. Often, the technology behind Torrents, gets overshadowed by the constant inquisition about the morality of it’s usage.</p> <p>Only on delving deeper into the technology behind it, does one get to truly appreciate it’s brilliance. Without further ado, let’s jump right into it.</p> <p>Let’s start by understanding what a <em>p2p</em> application is.</p> <h2 id="a-brief-about-p2p-networking">A Brief about p2p networking</h2> <p>It’s an alternative to traditional Client Server architecture, wherein each member in the network is equal (more or less) and contributes in delivering the service the network is intended to provide. This implies that the role of a central server is nearly redundant. Such a system brings in some noteworthy advantages over the traditional approach -</p> <ul> <li>It improves availability by removing single point failures (though admittedly a well distributed server client system can do the same)</li> <li>There is no money spent on making data warehouses, large servers or establishing connections with monumental bandwidths. It distributes the storage, compute and bandwidth required across all the users on the network.</li> </ul> <p>It builds a self reliant ecosystem where everyone contributes and benefits. An application which uses such an approach to deliver the service is called a p2p application. Torrents happen to be amongst the mostly widely used p2p applications. Following this, let’s introduce ourselves to the BitTorrent (protocol): The primary Protocol used by torrents for the p2p transfer of files.</p> <h2 id="bittorrent-protocol">BitTorrent Protocol</h2> <h3 id="terminology">Terminology</h3> <ol> <li> <p><strong>Client</strong> : The program that enables p2p file sharing via the BitTorrent protocol.</p> </li> <li> <p><strong>Peer</strong> : A peer is one instance of a BitTorrent client running on a computer on the Internet to which other clients connect and transfer data.</p> </li> <li> <p><strong>Seeder</strong> : A peer that has the complete file and is now acting as a source for others. Having high numbers of seeders is huge positive as it’s a measure of availability.</p> </li> <li> <p><strong>Leecher</strong> : They’re peers who are in the process of downloading the file. They have parts of the file and keep gathering more parts over time. Once they finish their download, they become Seeders. They also act as sources of the parts of the files they’ve downloaded.</p> </li> </ol> <h3 id="format-of-the-file">Format of the File</h3> <p>The file is divided into pieces (also referred to as fragments), which are further split into sub-pieces. Clients can download a sub-piece from only one peer at a time. Therefore, to parallelise the download process, multiple sub-pieces are downloaded simultaneously from different peers.</p> <h3 id="tracker">Tracker</h3> <p>A tracker plays a very important role in the BitTorrent ecosystem. The tracker maintains information about all clients utilising each torrent and the meta-data about the torrent. Specifically, the tracker identifies the network location of each client either uploading or downloading the files associated with a torrent. It also tracks which fragment of that file each client possesses, to assist in efficient data sharing between clients. It’s essential to note that the tracker does not hold a copy of the file. It merely contains the meta data about the peers having or building copies of the file and information about the fragments that make up the complete file. So when a client approaches the Tracker to download the file, it simply reverts with the information about the peers involved in the file transfer and info about the file itself.</p> <h3 id="initial-upload">Initial Upload</h3> <p>When a new torrent is released, it’s seeded by a single peer, the peer releasing it. The peer registers the torrent with the Tracker (or with any of the Trackers in case of multi-tracker network). A torrent file is generated for the new release containing the address of the Tracker. Initially the original seeder is the only peer having a copy of the file. As peers start to download the file, the numbers of seeders and leechers increase, thus increasing the available copies of the file.</p> <h3 id="downloading-requests">Downloading Requests</h3> <p>When a peer starts downloading a particular torrent, it approaches a tracker associated with it. The Tracker relays meta-data about the torrent and the peers involved in the download. Using the algorithms mentioned later, the peer pings other peers and downloads the various pieces of the file. The actual sub-piece download is done using TCP protocol at network layer. To download the sub-pieces, the peer makes requests to other peers. These request are queued in a pipeline. It’s imperative to maintain the pipeline as BitTorrent uses TCP which implements a slow start mechanism. It is thus crucial to always transfer data or else the transfer rate will drop.</p> <h3 id="file-sharing-algorithm-used-by-peers">File Sharing Algorithm Used by Peers.</h3> <p>In a p2p network, the Peers themselves decide whom to download the pieces from. They follow the BitTorrent Protocol rules. These rules are essential to facilitate proper functioning of the network.</p> <p>Following are some of the rules that Clients follow while downloading-</p> <h4 id="piece-selection-algorithm">Piece Selection Algorithm</h4> <p>This is how the client decide which piece to download next. Piece selection is done to achieve a primary goal- Replication of different pieces on different peers as soon as possible. This will increase the download speed, and also make sure that all pieces of a file is somewhere in the network if the seeder leaves. While downloading the peers use the following rules to maximise they efficiency-</p> <ul> <li> <p><strong>Strict Policy</strong> : It prioritises of completion of a single piece over partial download of multiple pieces. Once a sub-piece is requested by the peer, other sub-pieces of the same piece are requested to be downloaded before others.</p> </li> <li> <p><strong>Rarest First</strong> : This aligns directly with the goal, wherein the next piece to be downloaded is the one which has fewest replicas. Not only does increase the availability but it also increases the download speeds for other peers looking for the piece.</p> </li> <li> <p><strong>Random First Piece</strong> : Since Bit-torrent protocol requires a peer to balance it’s upload and download, it’s wise to download the first piece as soon as possible. In coherence with this idea, the first piece is downloaded randomly instead to following the rarest first policy. Once the first piece is downloaded, the peer commences with the rarest first policy.</p> </li> <li> <p><strong>Endgame Mode</strong> : Towards the end of the download, when all the only sub-pieces remaining are the ones in the pipeline, the request is broadcasted to all peers. On the arrival of a sub-piece, a corresponding cancel request is sent. The network congestion caused by this is less than expected because of the it’s short duration.</p> </li> </ul> <h4 id="resource-allocation">Resource Allocation</h4> <p>The resource allocation of peers is managed by the peer themselves. Therefore the peers use protocols that award other peers who have been contributing and snubs those who haven’t been uploading themselves. This forces all peers to upload in order to maintain good download speeds. The aim for every node is to establish bidirectional channels with other peers, where both download and upload nearly the same amount to one another. This builds a stable p2p connection between the two nodes. To attain this goal, every peer uses the following strategies-</p> <ul> <li> <p>The peer cooperates on the first request made by any node. This is to initiate the communication between them.</p> </li> <li> <p>On the successive requests, the peers cooperation commensurates with cooperation received from the other peer.</p> </li> <li> <p><strong>Choking Algorithm</strong> : Peers always maintain a fixed number of unchoked peers. These are the peers that they are willing to upload to. These peers are selected on the upload rate offered by them. This provides an incentive to other peers to be good uploaders. If the unchoked peers are changed too often, the download speeds fall because of the slow start mechanism of TCP transfer. Therefore the list of unchoked peers is updated after a duration of 20 seconds.</p> </li> <li> <p><strong>Optimistic Unchoking</strong> : Peers select a random peer that they unchoke irrespective of the upload speed it offers. This peer is used as a wildcard entry to replace the peers selected by the choking algorithm. This allows the peer to discover new nodes which might offer better upload speeds. This peer is changed every 30 seconds. If in the duration, this peers is able to offer better upload speed than any of the other unchoked peers, they are swapped.</p> </li> <li> <p><strong>Anti-Snubbing</strong> : When a peer stops receiving data from a peer for about 60 seconds, it assumes that it has snubbed by that particular peer. To replace it, the node increases the number of Optimistically Unchoked peers. This allows the peer to recover faster in a scenario where it is snubbed by a large at the same time.</p> </li> <li> <p><strong>Upload Only</strong> : After a peer finishes a download, it uploads to peers having the highest download rate. This allows quick replication of data in the network.</p> </li> </ul> <p>These policies ensure that the pieces are replicated, and that every peer has the largest probability of retrieving the complete file, as quickly as possible. Inspired by “tit-for-tat”, the choking algorithm tries to prohibit “free riders” from destroying the dynamics of the peer-to-peer network. If a peer blocks other peers from uploading, he will soon be choked by them and thus affecting his download rate. The choking algorithm correlates the download rate to the upload rate. Uploading is encouraged and the price in return is a better chance for faster download</p> <p>The Bit-torrent protocol comes into play once the Client makes contact the Tracker. I’m sure you’re wondering how exactly does it manage to reach the tracker?</p> <h2 id="getting-to-the-tracker">Getting to the Tracker</h2> <p>Originally there was a single tracker for each torrent. This would be a special node entrusted to track the fragments of the torrent and the peers involved in the download. The location to this Tracker would be in the Torrent file. The torrent file would be listed on multiple web portals. Peers use these torrent file to get to the Tracker which in turns provides them the details to commence downloading the Torrent fragments. It’s evident what the drawbacks of such a system are. The single Tracker represents a single point failure and makes the system amenable to Denial Of Service Attacks. To fix this Multi-Tracker Torrents were introduced.</p> <h3 id="multi-tracker-torrents">Multi-Tracker Torrents</h3> <p>To tackle the aforementioned drawbacks of a single tracker, Multi-Tracker Torrents were devised. In this approach, every node in the network is equivalent. Trackers weren’t special nodes anymore. <a href="https://github.com/hydra-hoard/hydra/wiki/Distributed-Hash-Table-(DHT)-Algorithm" rel="external nofollow noopener" target="_blank">Distributed Hash Tables (DHTs)</a> were used to find and reach the Tracker to any Torrent. The torrent file now only contained the Hash of the Torrent, which would allow Peers to reach the Tracker using DHTs. Consistency amongst the Trackers is a different story in itself.</p> </article> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2022 Vaibhav Mathur. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js" integrity="sha256-EdPgYcPk/IIrw7FYeuJQexva49pVRZNmt3LculEr7zM=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js"></script> <script defer src="/assets/js/common.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>