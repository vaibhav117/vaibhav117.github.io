<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>Advanced Go Concurrency Patterns | Vaibhav Mathur</title> <meta name="author" content="Vaibhav Mathur"> <meta name="description" content="A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. "> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700%7CRoboto+Slab:100,300,400,500,700%7CMaterial+Icons"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css"> <link rel="canonical" href="https://vaibhav117.github.io/blog/2018/Advanced_Go_Concurrency_Patterns/"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js"></script> <script src="/assets/js/dark_mode.js"></script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"><span class="font-weight-bold">Vaibhav </span>Mathur</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about</a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog<span class="sr-only">(current)</span></a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">Publications</a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv</a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5"> <div class="post"> <header class="post-header"> <h1 class="post-title">Advanced Go Concurrency Patterns</h1> <p class="post-meta">July 11, 2018</p> <p class="post-tags"> <a href="/blog/2018"> <i class="fas fa-calendar fa-sm"></i> 2018 </a> </p> </header> <article class="post-content"> <p>Concurrency in Go is implemented using Goroutines. Goroutines are functions or methods that run concurrently with other functions or methods. They can be thought of as light weight threads. The cost of creating a Goroutine is tiny when compared to a thread. Hence it’s common for Go applications to have thousands of Goroutines running concurrently.</p> <p>In-order to communicate between these Goroutines, Go implements channels. Channels send and receive data until the other side is ready. This allows Goroutines to synchronize without explicit locks or condition variables.</p> <h2 id="synchronized-channels">Synchronized Channels</h2> <p>Channels that don’t have a buffer size are called Synchronized Channels. The write and read functions halt till they are resolved. For instance- when we apply a read from a channel :</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="o">&lt;-</span><span class="n">channel</span>
</code></pre></div></div> <p>The execution would not proceed beyond that line of code till the channel has a value to execute the read function. Similarly, in case of-</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">channel</span> <span class="o">&lt;-</span> <span class="m">4</span>
</code></pre></div></div> <p>The execution halts till a reader removes the input. This allows us to synchronize Goroutines which otherwise work independently.</p> <h2 id="challenges-faced-in-making-goroutines">Challenges Faced in making Goroutines</h2> <p>The following problems occur commonly if Goroutines are used too cavalierly-</p> <h4 id="go-routines-dead-lock">Go Routines Dead Lock</h4> <p>It is a state when none of the Go routines are able to proceed. i.e - they are waiting for the other ones to provide a means of completion.</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
     <span class="n">c</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">int</span><span class="p">)</span>
     <span class="n">c</span> <span class="o">&lt;-</span> <span class="m">42</span>    <span class="c">// write to a channel</span>
     <span class="n">val</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="n">c</span> <span class="c">// read from a channel</span>
     <span class="nb">println</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div> <p>In the above code a deadlock is formed because the code execution stops at <strong>c &lt;- 42</strong> and the statement <strong>val := &lt;-c</strong> is never evaluated.</p> <h4 id="race-conditions-in-go">Race conditions in GO</h4> <p>A race condition is when two or more routines have access to the same resource, such as a variable or data structure and attempt to read and write to that resource without any regard to the other routines. This type of code can create the craziest and most random bugs you have ever seen. It usually takes a tremendous amount of logging and luck to find these types of bugs Race conditions arise if we fire two Go Routines without proper initiation.</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">(</span>
    <span class="s">"fmt"</span>
    <span class="s">"sync"</span>
<span class="p">)</span>

<span class="k">var</span> <span class="n">Counter</span> <span class="kt">int</span> <span class="o">=</span> <span class="m">0</span>

<span class="k">func</span> <span class="n">Routine</span><span class="p">(</span><span class="n">id</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="n">count</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="m">2</span><span class="p">;</span> <span class="n">count</span><span class="o">++</span> <span class="p">{</span>
        <span class="n">value</span> <span class="o">:=</span> <span class="n">Counter</span>
        <span class="n">value</span><span class="o">++</span>
        <span class="n">Counter</span> <span class="o">=</span> <span class="n">value</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">for</span> <span class="n">routine</span> <span class="o">:=</span> <span class="m">1</span><span class="p">;</span> <span class="n">routine</span> <span class="o">&lt;=</span> <span class="m">2</span><span class="p">;</span> <span class="n">routine</span><span class="o">++</span> <span class="p">{</span>
        <span class="k">go</span> <span class="n">Routine</span><span class="p">(</span><span class="n">routine</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>In the above code, both Goroutines are racing to get the value <em>Counter</em> , add one to the value and write it back to <em>Counter</em>. In such a scenario, one of the Goroutines might alter the value of <em>Counter</em> after the other reads but before writes to it. So when the second Routine writes to <em>Counter</em>, it does so with the outdated value.</p> <p>Fortunately, Go provision to detect Race conditions. It can be detected using the following code-</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>go run <span class="nt">-race</span> file.go
</code></pre></div></div> <h4 id="sleep-in-go-routines">Sleep in Go routines</h4> <p>Go routines become unresponsive when in sleep mode. Therefore, if a condition occurs where we have to programmatically close the go routines without closing the program, the Go routines are lost and hog the cpu till there sleep ends. This is could be harmful in cases having long sleep durations. These Go routines would not be cleared for a long while.</p> <p>Let’s look at how to write programs that handle communication, periodic events, and cancellation. These can be mitigated using proper usage of Select construct.</p> <h2 id="select-construct">Select Construct</h2> <p>The core is Go’s select statement: like a switch, but the decision is made based on the ability to communicate.</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">select</span> <span class="p">{</span>
<span class="k">case</span> <span class="n">xc</span> <span class="o">&lt;-</span> <span class="n">x</span><span class="o">:</span>
    <span class="c">// sent x on xc</span>
<span class="k">case</span> <span class="n">y</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="n">yc</span><span class="o">:</span>
    <span class="c">// received y from yc</span>
<span class="p">}</span>
</code></pre></div></div> <p>Select statement holds execution till one of it’s conditions is satisfied. This way all conditions can be checked simultaneously without being blocked at a statement. a default condition can also be added, if it is required to be executed if none of the conditions are satisfied. In that scenario, the select construct won’t wait if none of the conditions are satisfied.</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">select</span> <span class="p">{</span>
<span class="k">case</span> <span class="n">xc</span> <span class="o">&lt;-</span> <span class="n">x</span><span class="o">:</span>
    <span class="c">// sent x on xc</span>
<span class="k">case</span> <span class="n">y</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="n">yc</span><span class="o">:</span>
    <span class="c">// received y from yc</span>
<span class="k">default</span><span class="o">:</span>
  <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"No condition satisfied"</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div> <p>When more than one condition is satisfied, the case selected is at random between the successful ones.</p> <p>By using the Select Construct we can avoid dead locks as we provide an alternative to the program, if the read or write on the channel cannot proceed.</p> <p>Race conditions can also be resolved by proper implementation of channels select construct, without having to use Locks for Synchronization.</p> <h2 id="timeout-in-goroutine">Timeout in Goroutine</h2> <p>As noted above, using <strong><em>sleep</em></strong> in Go could possibly lead to rogue Goroutines. To avoid this we refrain from using sleep() at all. This is facilitated by the usage of <strong><em>Timeouts__**. **_Timeouts__** coupled with switch construct, provide an alternative to **_sleep</em></strong> in the following manner-</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">select</span> <span class="p">{</span>
    <span class="k">case</span> <span class="o">&lt;-</span><span class="n">time</span><span class="o">.</span><span class="n">After</span><span class="p">(</span><span class="m">1</span> <span class="o">*</span> <span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">)</span><span class="o">:</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"timeout 1"</span><span class="p">)</span>
    <span class="p">}</span>
</code></pre></div></div> <p>So instead of using <strong><em>sleep</em></strong>, before we run <em>case res := &lt;-c1</em>, we use Timeout along with Switch Construct.</p> <p>This allows the Goroutine to be responsive even after adding a delay in it’s execution.</p> </article> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2022 Vaibhav Mathur. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js" integrity="sha256-EdPgYcPk/IIrw7FYeuJQexva49pVRZNmt3LculEr7zM=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js"></script> <script defer src="/assets/js/common.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>